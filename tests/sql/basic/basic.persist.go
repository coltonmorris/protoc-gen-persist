// This file is generated by protoc-gen-persist
// Source File: tests/sql/basic/basic.proto
// DO NOT EDIT !
package basic

import (
	sql "database/sql"
	driver "database/sql/driver"
	fmt "fmt"
	io "io"

	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	persist_lib "github.com/tcncloud/protoc-gen-persist/tests/sql/basic/persist_lib"
	test "github.com/tcncloud/protoc-gen-persist/tests/test"
	context "golang.org/x/net/context"
	codes "google.golang.org/grpc/codes"
	gstatus "google.golang.org/grpc/status"
)

type AmazingImpl struct {
	PERSIST   *persist_lib.AmazingMethodReceiver
	FORWARDED RestOfAmazingHandlers
	HOOKS     AmazingHooks
	MAPPINGS  AmazingTypeMapping
}
type RestOfAmazingHandlers interface {
	UnImplementedPersistMethod(ctx context.Context, req *test.ExampleTable) (*test.ExampleTable, error)
	NoGenerationForBadReturnTypes(ctx context.Context, req *test.ExampleTable) (*BadReturn, error)
}
type AmazingTypeMapping interface {
	TimestampTimestamp() AmazingTimestampTimestampMappingImpl
}
type AmazingTimestampTimestampMappingImpl interface {
	ToProto(**timestamp.Timestamp) error
	ToSql(*timestamp.Timestamp) sql.Scanner
	Empty() AmazingTimestampTimestampMappingImpl
	sql.Scanner
	driver.Valuer
}
type AmazingHooks interface {
	UniarySelectWithHooksBeforeHook(*test.PartialTable) (*test.ExampleTable, error)
	UniarySelectWithHooksAfterHook(*test.PartialTable, *test.ExampleTable) error
	ServerStreamWithHooksBeforeHook(*test.Name) ([]*test.ExampleTable, error)
	ServerStreamWithHooksAfterHook(*test.Name, *test.ExampleTable) error
	BidirectionalWithHooksBeforeHook(*test.ExampleTable) (*test.ExampleTable, error)
	BidirectionalWithHooksAfterHook(*test.ExampleTable, *test.ExampleTable) error
	ClientStreamWithHookBeforeHook(*test.ExampleTable) (*test.Ids, error)
	ClientStreamWithHookAfterHook(*test.ExampleTable, *test.Ids) error
}
type AmazingImplBuilder struct {
	err           error
	rest          RestOfAmazingHandlers
	queryHandlers *persist_lib.AmazingQueryHandlers
	i             *AmazingImpl
	db            *sql.DB
	hooks         AmazingHooks
	mappings      AmazingTypeMapping
}

func NewAmazingBuilder() *AmazingImplBuilder {
	return &AmazingImplBuilder{i: &AmazingImpl{}}
}
func (b *AmazingImplBuilder) WithHooks(hs AmazingHooks) *AmazingImplBuilder {
	b.hooks = hs
	return b
}
func (b *AmazingImplBuilder) WithTypeMapping(ts AmazingTypeMapping) *AmazingImplBuilder {
	b.mappings = ts
	return b
}
func (b *AmazingImplBuilder) WithRestOfGrpcHandlers(r RestOfAmazingHandlers) *AmazingImplBuilder {
	b.rest = r
	return b
}
func (b *AmazingImplBuilder) WithPersistQueryHandlers(p *persist_lib.AmazingQueryHandlers) *AmazingImplBuilder {
	b.queryHandlers = p
	return b
}
func (b *AmazingImplBuilder) WithDefaultQueryHandlers() *AmazingImplBuilder {
	accessor := persist_lib.NewSqlClientGetter(&b.db)
	queryHandlers := &persist_lib.AmazingQueryHandlers{
		UniarySelectHandler:           persist_lib.DefaultUniarySelectHandler(accessor),
		UniarySelectWithHooksHandler:  persist_lib.DefaultUniarySelectWithHooksHandler(accessor),
		ServerStreamHandler:           persist_lib.DefaultServerStreamHandler(accessor),
		ServerStreamWithHooksHandler:  persist_lib.DefaultServerStreamWithHooksHandler(accessor),
		BidirectionalHandler:          persist_lib.DefaultBidirectionalHandler(accessor),
		BidirectionalWithHooksHandler: persist_lib.DefaultBidirectionalWithHooksHandler(accessor),
		ClientStreamHandler:           persist_lib.DefaultClientStreamHandler(accessor),
		ClientStreamWithHookHandler:   persist_lib.DefaultClientStreamWithHookHandler(accessor),
	}
	b.queryHandlers = queryHandlers
	return b
}
func (b *AmazingImplBuilder) WithNilAsDefaultQueryHandlers(p *persist_lib.AmazingQueryHandlers) *AmazingImplBuilder {
	accessor := persist_lib.NewSqlClientGetter(&b.db)
	if p.UniarySelectHandler == nil {
		p.UniarySelectHandler = persist_lib.DefaultUniarySelectHandler(accessor)
	}
	if p.UniarySelectWithHooksHandler == nil {
		p.UniarySelectWithHooksHandler = persist_lib.DefaultUniarySelectWithHooksHandler(accessor)
	}
	if p.ServerStreamHandler == nil {
		p.ServerStreamHandler = persist_lib.DefaultServerStreamHandler(accessor)
	}
	if p.ServerStreamWithHooksHandler == nil {
		p.ServerStreamWithHooksHandler = persist_lib.DefaultServerStreamWithHooksHandler(accessor)
	}
	if p.BidirectionalHandler == nil {
		p.BidirectionalHandler = persist_lib.DefaultBidirectionalHandler(accessor)
	}
	if p.BidirectionalWithHooksHandler == nil {
		p.BidirectionalWithHooksHandler = persist_lib.DefaultBidirectionalWithHooksHandler(accessor)
	}
	if p.ClientStreamHandler == nil {
		p.ClientStreamHandler = persist_lib.DefaultClientStreamHandler(accessor)
	}
	if p.ClientStreamWithHookHandler == nil {
		p.ClientStreamWithHookHandler = persist_lib.DefaultClientStreamWithHookHandler(accessor)
	}
	b.queryHandlers = p
	return b
}
func (b *AmazingImplBuilder) WithSqlClient(c *sql.DB) *AmazingImplBuilder {
	b.db = c
	return b
}
func (b *AmazingImplBuilder) WithNewSqlDb(driverName, dataSourceName string) *AmazingImplBuilder {
	db, err := sql.Open(driverName, dataSourceName)
	b.err = err
	if b.err == nil {
		b.db = db
	}
	return b
}
func (b *AmazingImplBuilder) Build() (*AmazingImpl, error) {
	if b.err != nil {
		return nil, b.err
	}
	b.i.PERSIST = &persist_lib.AmazingMethodReceiver{Handlers: *b.queryHandlers}
	b.i.FORWARDED = b.rest
	b.i.HOOKS = b.hooks
	b.i.MAPPINGS = b.mappings
	return b.i, nil
}
func (b *AmazingImplBuilder) MustBuild() *AmazingImpl {
	s, err := b.Build()
	if err != nil {
		panic("error in builder: " + err.Error())
	}
	return s
}
func PartialTableToAmazingPersistType(serv AmazingTypeMapping, req *test.PartialTable) (*persist_lib.Test_PartialTableForAmazing, error) {
	params := &persist_lib.Test_PartialTableForAmazing{}
	params.Id = req.Id
	{
		mapper := serv.TimestampTimestamp()
		params.StartTime = mapper.ToSql(req.StartTime)
	}
	return params, nil
}
func ExampleTableFromAmazingDatabaseRow(serv AmazingTypeMapping, row persist_lib.Scanable) (*test.ExampleTable, error) {
	res := &test.ExampleTable{}
	var Id_ int64
	StartTime_ := serv.TimestampTimestamp().Empty()
	var Name_ string
	if err := row.Scan(
		&Id_,
		StartTime_,
		&Name_,
	); err != nil && err != sql.ErrNoRows {
		return nil, err
	}
	res.Id = Id_
	if err := StartTime_.ToProto(&res.StartTime); err != nil {
		return nil, err
	}
	res.Name = Name_
	return res, nil
}
func IterAmazingExampleTableProto(ms AmazingTypeMapping, iter *persist_lib.Result, next func(i *test.ExampleTable) error) error {
	return iter.Do(func(r persist_lib.Scanable) error {
		item, err := ExampleTableFromAmazingDatabaseRow(ms, r)
		if err != nil {
			return fmt.Errorf("error converting test.ExampleTable row to protobuf message: %s", err)
		}
		return next(item)
	})
}
func NameToAmazingPersistType(serv AmazingTypeMapping, req *test.Name) (*persist_lib.Test_NameForAmazing, error) {
	params := &persist_lib.Test_NameForAmazing{}
	params.Name = req.Name
	return params, nil
}
func ExampleTableToAmazingPersistType(serv AmazingTypeMapping, req *test.ExampleTable) (*persist_lib.Test_ExampleTableForAmazing, error) {
	params := &persist_lib.Test_ExampleTableForAmazing{}
	params.Id = req.Id
	{
		mapper := serv.TimestampTimestamp()
		params.StartTime = mapper.ToSql(req.StartTime)
	}
	params.Name = req.Name
	return params, nil
}
func NumRowsFromAmazingDatabaseRow(serv AmazingTypeMapping, row persist_lib.Scanable) (*test.NumRows, error) {
	res := &test.NumRows{}
	var Count_ int64
	if err := row.Scan(
		&Count_,
	); err != nil && err != sql.ErrNoRows {
		return nil, err
	}
	res.Count = Count_
	return res, nil
}
func IterAmazingNumRowsProto(ms AmazingTypeMapping, iter *persist_lib.Result, next func(i *test.NumRows) error) error {
	return iter.Do(func(r persist_lib.Scanable) error {
		item, err := NumRowsFromAmazingDatabaseRow(ms, r)
		if err != nil {
			return fmt.Errorf("error converting test.NumRows row to protobuf message: %s", err)
		}
		return next(item)
	})
}
func IdsFromAmazingDatabaseRow(serv AmazingTypeMapping, row persist_lib.Scanable) (*test.Ids, error) {
	res := &test.Ids{}
	var Ids_ []int64
	if err := row.Scan(
		&Ids_,
	); err != nil && err != sql.ErrNoRows {
		return nil, err
	}
	res.Ids = Ids_
	return res, nil
}
func IterAmazingIdsProto(ms AmazingTypeMapping, iter *persist_lib.Result, next func(i *test.Ids) error) error {
	return iter.Do(func(r persist_lib.Scanable) error {
		item, err := IdsFromAmazingDatabaseRow(ms, r)
		if err != nil {
			return fmt.Errorf("error converting test.Ids row to protobuf message: %s", err)
		}
		return next(item)
	})
}
func (s *AmazingImpl) UniarySelect(ctx context.Context, req *test.PartialTable) (*test.ExampleTable, error) {
	var err error
	var res = &test.ExampleTable{}
	_ = err
	_ = res
	params, err := PartialTableToAmazingPersistType(s.MAPPINGS, req)
	if err != nil {
		return nil, err
	}
	var iterErr error
	err = s.PERSIST.UniarySelect(ctx, params, func(row persist_lib.Scanable) {
		if row == nil { // there was no return data
			return
		}
		res, err = ExampleTableFromAmazingDatabaseRow(s.MAPPINGS, row)
		if err != nil {
			iterErr = err
			return
		}
	})
	if err != nil {
		return nil, gstatus.Errorf(codes.Unknown, "error calling persist service: %v", err)
	} else if iterErr != nil {
		return nil, iterErr
	}
	return res, nil
}
func (s *AmazingImpl) UniarySelectWithHooks(ctx context.Context, req *test.PartialTable) (*test.ExampleTable, error) {
	var err error
	var res = &test.ExampleTable{}
	_ = err
	_ = res
	beforeRes, err := s.HOOKS.UniarySelectWithHooksBeforeHook(req)
	if err != nil {
		return nil, gstatus.Errorf(codes.Unknown, "error in before hook: %v", err)
	} else if beforeRes != nil {
		return beforeRes, nil
	}
	params, err := PartialTableToAmazingPersistType(s.MAPPINGS, req)
	if err != nil {
		return nil, err
	}
	var iterErr error
	err = s.PERSIST.UniarySelectWithHooks(ctx, params, func(row persist_lib.Scanable) {
		if row == nil { // there was no return data
			return
		}
		res, err = ExampleTableFromAmazingDatabaseRow(s.MAPPINGS, row)
		if err != nil {
			iterErr = err
			return
		}
	})
	if err != nil {
		return nil, gstatus.Errorf(codes.Unknown, "error calling persist service: %v", err)
	} else if iterErr != nil {
		return nil, iterErr
	}
	if err := s.HOOKS.UniarySelectWithHooksAfterHook(req, res); err != nil {
		return nil, gstatus.Errorf(codes.Unknown, "error in after hook: %v", err)
	}
	return res, nil
}
func (s *AmazingImpl) ServerStream(req *test.Name, stream Amazing_ServerStreamServer) error {
	var err error
	_ = err
	params, err := NameToAmazingPersistType(s.MAPPINGS, req)
	if err != nil {
		return err
	}
	var iterErr error
	err = s.PERSIST.ServerStream(stream.Context(), params, func(row persist_lib.Scanable) {
		if row == nil { // there was no return data
			return
		}
		res, err := ExampleTableFromAmazingDatabaseRow(s.MAPPINGS, row)
		if err != nil {
			iterErr = err
			return
		}
		if err := stream.Send(res); err != nil {
			iterErr = gstatus.Errorf(codes.Unknown, "error during iteration: %v", err)
		}
	})
	if err != nil {
		return gstatus.Errorf(codes.Unknown, "error during iteration: %v", err)
	} else if iterErr != nil {
		return iterErr
	}
	return nil
}
func (s *AmazingImpl) ServerStreamWithHooks(req *test.Name, stream Amazing_ServerStreamWithHooksServer) error {
	var err error
	_ = err
	beforeRes, err := s.HOOKS.ServerStreamWithHooksBeforeHook(req)
	if err != nil {
		return gstatus.Errorf(codes.Unknown, "error in before hook: %v", err)
	} else if beforeRes != nil {
		for _, res := range beforeRes {
			if err := stream.Send(res); err != nil {
				return gstatus.Errorf(codes.Unknown, "error sending back before hook result: %v", err)
			}
		}
	}
	params, err := NameToAmazingPersistType(s.MAPPINGS, req)
	if err != nil {
		return err
	}
	var iterErr error
	err = s.PERSIST.ServerStreamWithHooks(stream.Context(), params, func(row persist_lib.Scanable) {
		if row == nil { // there was no return data
			return
		}
		res, err := ExampleTableFromAmazingDatabaseRow(s.MAPPINGS, row)
		if err != nil {
			iterErr = err
			return
		}
		if err := s.HOOKS.ServerStreamWithHooksAfterHook(req, res); err != nil {
			iterErr = gstatus.Errorf(codes.Unknown, "error in after hook: %v", err)
			return
		}
		if err := stream.Send(res); err != nil {
			iterErr = gstatus.Errorf(codes.Unknown, "error during iteration: %v", err)
		}
	})
	if err != nil {
		return gstatus.Errorf(codes.Unknown, "error during iteration: %v", err)
	} else if iterErr != nil {
		return iterErr
	}
	return nil
}
func (s *AmazingImpl) Bidirectional(stream Amazing_BidirectionalServer) error {
	var err error
	_ = err
	feed, stop := s.PERSIST.Bidirectional(stream.Context())
	for {
		req, err := stream.Recv()
		if err == io.EOF {
			break
		} else if err != nil {
			return gstatus.Errorf(codes.Unknown, "error receiving request: %v", err)
		}
		params, err := ExampleTableToAmazingPersistType(s.MAPPINGS, req)
		if err != nil {
			return err
		}
		row, err := feed(params)
		if err != nil {
			return gstatus.Errorf(codes.Unknown, "error receiving result row: %v", err)
		}
		if row != nil {
			res, err := ExampleTableFromAmazingDatabaseRow(s.MAPPINGS, row)
			if err != nil {
				return err
			}
			if err := stream.Send(res); err != nil {
				return err
			}
		}
	}
	return stop()
}
func (s *AmazingImpl) BidirectionalWithHooks(stream Amazing_BidirectionalWithHooksServer) error {
	var err error
	_ = err
	feed, stop := s.PERSIST.BidirectionalWithHooks(stream.Context())
	for {
		req, err := stream.Recv()
		if err == io.EOF {
			break
		} else if err != nil {
			return gstatus.Errorf(codes.Unknown, "error receiving request: %v", err)
		}
		beforeRes, err := s.HOOKS.BidirectionalWithHooksBeforeHook(req)
		if err != nil {
			return gstatus.Errorf(codes.Unknown, "error in before hook: %v", err)
		} else if beforeRes != nil {
			continue
		}
		params, err := ExampleTableToAmazingPersistType(s.MAPPINGS, req)
		if err != nil {
			return err
		}
		row, err := feed(params)
		if err != nil {
			return gstatus.Errorf(codes.Unknown, "error receiving result row: %v", err)
		}
		if row != nil {
			res, err := ExampleTableFromAmazingDatabaseRow(s.MAPPINGS, row)
			if err != nil {
				return err
			}
			if err := s.HOOKS.BidirectionalWithHooksAfterHook(req, res); err != nil {
				return gstatus.Errorf(codes.Unknown, "error in after hook: %v", err)
			}
			if err := stream.Send(res); err != nil {
				return err
			}
		}
	}
	return stop()
}
func (s *AmazingImpl) ClientStream(stream Amazing_ClientStreamServer) error {
	var err error
	_ = err
	res := &test.NumRows{}
	feed, stop, err := s.PERSIST.ClientStream(stream.Context())
	if err != nil {
		return err
	}
	for {
		req, err := stream.Recv()
		if err == io.EOF {
			break
		} else if err != nil {
			return gstatus.Errorf(codes.Unknown, "error receiving request: %v", err)
		}
		params, err := ExampleTableToAmazingPersistType(s.MAPPINGS, req)
		if err != nil {
			return err
		}
		if err := feed(params); err != nil {
			return err
		}
	}
	row, err := stop()
	if err != nil {
		return gstatus.Errorf(codes.Unknown, "error receiving result row: %v", err)
	}
	if row != nil {
		res, err = NumRowsFromAmazingDatabaseRow(s.MAPPINGS, row)
		if err != nil {
			return err
		}
	}
	if err := stream.SendAndClose(res); err != nil {
		return gstatus.Errorf(codes.Unknown, "error sending back response: %v", err)
	}
	return nil
}
func (s *AmazingImpl) ClientStreamWithHook(stream Amazing_ClientStreamWithHookServer) error {
	var err error
	_ = err
	res := &test.Ids{}
	feed, stop, err := s.PERSIST.ClientStreamWithHook(stream.Context())
	if err != nil {
		return err
	}
	for {
		req, err := stream.Recv()
		if err == io.EOF {
			break
		} else if err != nil {
			return gstatus.Errorf(codes.Unknown, "error receiving request: %v", err)
		}
		beforeRes, err := s.HOOKS.ClientStreamWithHookBeforeHook(req)
		if err != nil {
			return gstatus.Errorf(codes.Unknown, "error in before hook: %v", err)
		} else if beforeRes != nil {
			continue
		}
		params, err := ExampleTableToAmazingPersistType(s.MAPPINGS, req)
		if err != nil {
			return err
		}
		if err := feed(params); err != nil {
			return err
		}
	}
	row, err := stop()
	if err != nil {
		return gstatus.Errorf(codes.Unknown, "error receiving result row: %v", err)
	}
	if row != nil {
		res, err = IdsFromAmazingDatabaseRow(s.MAPPINGS, row)
		if err != nil {
			return err
		}
	}
	// NOTE: I dont want to store your requests in memory
	// so the after hook for client streaming calls
	// is called with an empty request struct
	fakeReq := &test.ExampleTable{}
	if err := s.HOOKS.ClientStreamWithHookAfterHook(fakeReq, res); err != nil {
		return gstatus.Errorf(codes.Unknown, "error in after hook: %v", err)
	}
	if err := stream.SendAndClose(res); err != nil {
		return gstatus.Errorf(codes.Unknown, "error sending back response: %v", err)
	}
	return nil
}
func (s *AmazingImpl) UnImplementedPersistMethod(ctx context.Context, req *test.ExampleTable) (*test.ExampleTable, error) {
	return s.FORWARDED.UnImplementedPersistMethod(ctx, req)
}
func (s *AmazingImpl) NoGenerationForBadReturnTypes(ctx context.Context, req *test.ExampleTable) (*BadReturn, error) {
	return s.FORWARDED.NoGenerationForBadReturnTypes(ctx, req)
}
