// This file is generated by protoc-gen-persist
// Source File: examples/spanner/import_tests/persist_and_go.proto
// DO NOT EDIT !
package service

import (
	io "io"
	strings "strings"

	"cloud.google.com/go/spanner"
	mytime "github.com/tcncloud/protoc-gen-persist/examples/mytime"
	pb "github.com/tcncloud/protoc-gen-persist/examples/spanner/import_tests"
	test "github.com/tcncloud/protoc-gen-persist/examples/test"
	context "golang.org/x/net/context"
	iterator "google.golang.org/api/iterator"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
)

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// WARNING ! WARNING ! WARNING ! WARNING !WARNING ! WARNING !
// In order for your code to work you have to create a file
// in this package with the following content:
//
// type MySpannerImpl struct {
// 	SpannerDB *spanner.Client
// }
// WARNING ! WARNING ! WARNING ! WARNING !WARNING ! WARNING !
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// spanner unary select UniaryInsert
func (s *MySpannerImpl) UniaryInsert(ctx context.Context, req *test.ExampleTable) (*pb.ExampleTable, error) {
	var err error

	beforeRes, err := TestBeforeHook(req)

	if err != nil {

		return nil, grpc.Errorf(codes.Unknown, err.Error())

	}
	if beforeRes != nil {

		return beforeRes, nil

	}

	params := make([]interface{}, 0)
	var conv interface{}

	conv = req.Id

	if err != nil {
		return nil, grpc.Errorf(codes.Unknown, err.Error())
	}
	params = append(params, conv)

	conv, err = mytime.MyTime{}.ToSpanner(req.StartTime).SpannerValue()

	if err != nil {
		return nil, grpc.Errorf(codes.Unknown, err.Error())
	}
	params = append(params, conv)
	params = append(params, "bananas")
	muts := make([]*spanner.Mutation, 1)
	muts[0] = spanner.Insert("example_table", []string{"id", "start_time", "name"}, params)
	_, err = s.SpannerDB.Apply(ctx, muts)
	if err != nil {
		if strings.Contains(err.Error(), "already exists") {
			return nil, grpc.Errorf(codes.AlreadyExists, err.Error())
		} else {
			return nil, grpc.Errorf(codes.Unknown, err.Error())
		}
	}
	res := pb.ExampleTable{}

	err = TestAfterHook(req, &res)

	if err != nil {

		return nil, grpc.Errorf(codes.Unknown, err.Error())

	}

	return &res, nil
}

// spanner server streaming ServerStream
func (s *MySpannerImpl) ServerStream(req *test.ExampleTable, stream pb.MySpanner_ServerStreamServer) error {
	var (
		Id        int64
		Name      string
		StartTime mytime.MyTime
	)

	var err error

	params := make(map[string]interface{})
	var conv interface{}

	conv, err = mytime.MyTime{}.ToSpanner(req.StartTime).SpannerValue()

	if err != nil {
		return grpc.Errorf(codes.Unknown, err.Error())
	}
	params["string0"] = conv
	stmt := spanner.Statement{SQL: "SELECT * FROM example_table WHERE start_time <  @string0", Params: params}
	tx := s.SpannerDB.Single()
	defer tx.Close()
	iter := tx.Query(context.Background(), stmt)
	defer iter.Stop()
	for {
		row, err := iter.Next()
		if err == iterator.Done {
			break
		} else if err != nil {
			return grpc.Errorf(codes.Unknown, err.Error())
		}
		// scan our values out of the row

		err = row.ColumnByName("id", &Id)
		if err != nil {
			return grpc.Errorf(codes.Unknown, err.Error())
		}

		gcv1 := new(spanner.GenericColumnValue)
		err = row.ColumnByName("start_time", gcv1)
		if err != nil {
			return grpc.Errorf(codes.Unknown, err.Error())
		}
		err = StartTime.SpannerScan(gcv1)
		if err != nil {
			return grpc.Errorf(codes.Unknown, err.Error())
		}

		err = row.ColumnByName("name", &Name)
		if err != nil {
			return grpc.Errorf(codes.Unknown, err.Error())
		}

		res := pb.ExampleTable{

			Id:        Id,
			Name:      Name,
			StartTime: StartTime.ToProto(),
		}

		stream.Send(&res)
	}
	return nil
}

// spanner client streaming ClientStream
func (s *MySpannerImpl) ClientStream(stream pb.MySpanner_ClientStreamServer) error {
	var err error
	res := pb.AggExampleTables{}

	reqs := make([]*test.ExampleTable, 0)

	muts := make([]*spanner.Mutation, 0)
	for {
		req, err := stream.Recv()
		if err == io.EOF {
			break
		} else if err != nil {
			return grpc.Errorf(codes.Unknown, err.Error())
		}

		reqs = append(reqs, req)

		//spanner client streaming update
		params := make(map[string]interface{})
		var conv interface{}

		conv, err = mytime.MyTime{}.ToSpanner(req.StartTime).SpannerValue()

		if err != nil {
			return grpc.Errorf(codes.Unknown, err.Error())
		}
		params["start_time"] = conv

		conv = req.Name

		if err != nil {
			return grpc.Errorf(codes.Unknown, err.Error())
		}
		params["name"] = conv

		conv = req.Id

		if err != nil {
			return grpc.Errorf(codes.Unknown, err.Error())
		}
		params["id"] = conv
		muts = append(muts, spanner.UpdateMap("example_table", params))

		////////////////////////////// NOTE //////////////////////////////////////
		// In the future, we might do apply if muts gets really big,  but for now,
		// we only do one apply on the database with all the records stored in muts
		//////////////////////////////////////////////////////////////////////////
	}
	_, err = s.SpannerDB.Apply(context.Background(), muts)
	if err != nil {
		if strings.Contains(err.Error(), "already exists") {
			return grpc.Errorf(codes.AlreadyExists, err.Error())
		} else {
			return grpc.Errorf(codes.Unknown, err.Error())
		}
	}

	for _, req := range reqs {

		err = AggRequests(req, &res)

		if err != nil {

			return grpc.Errorf(codes.Unknown, err.Error())

		}

	}

	stream.SendAndClose(&res)
	return nil
}
